<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>YCSEP DB</title>
  <link rel="apple-touch-icon" sizes="180x180" href="/static/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/static/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon-16x16.png">
  <link rel="manifest" href="/static/site.webmanifest">
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css"
        crossorigin="anonymous">
  <style>
    body { margin: 16px; font-size: 0.9rem; }
    th { cursor: pointer; }
    .audio-cell audio { width: 160px; }
    .sort-indicator { font-size: 0.7rem; color: #999; margin-left: 4px; }
    td { vertical-align: top; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    /* Filter row inputs */
    .filter-input { min-width: 110px; }
    .filter-cell { cursor: default !important; }

    /* Chips */
    .chips { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 6px; }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.18);
      font-size: 0.78rem;
      max-width: 100%;
    }
    .chip .chip-text { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 180px; }
    .chip .chip-x {
      border: 0;
      background: transparent;
      color: rgba(255,255,255,0.75);
      line-height: 1;
      padding: 0;
      margin: 0;
      cursor: pointer;
      font-size: 0.95rem;
    }
    .chip .chip-x:hover { color: #fff; }

    /* Highlight */
    mark.hl {
      padding: 0 0.08rem;
      border-radius: 0.2rem;
    }

    /* Help icon */
    .help-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid #ced4da;
      color: #495057;
      font-size: 0.85rem;
      cursor: pointer;
      user-select: none;
      background: #fff;
    }
    .help-icon:hover { background: #f8f9fa; }

    /* Optional sticky header */
    /* thead { position: sticky; top: 0; z-index: 10; } */
  </style>
</head>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>

<body class="container">

  <!-- Fair Use / Usage notice (always shown; dismissable) -->
  <div class="alert alert-warning alert-dismissible fade show text-center m-0 rounded-0" role="alert" style="z-index:1050;">
    <strong>Notice:</strong> This site contains copyrighted material made available for research, scholarship, and teaching under applicable laws (e.g., Singapore Copyright Act 2021; EU Directive 2019/790; U.S. 17 U.S.C. §107).
    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
  </div>

  <div class="d-flex justify-content-between align-items-end mb-3">
    <h1 class="h3">YCSEP_v2</h1>
    <small class="text-muted text-end" style="max-width: 60%;">
      This database contains transcript segments with associated audio from v2 of the <i>YouTube Corpus of Singapore English Podcasts</i>, transcribed with a fine-tuned ASR model (Coats et al., forthcoming). You can search by transcript text (e.g. <code>I just think</code>) or POS tags (e.g. <code>PRP RB VB</code>).
      Use the button to download a CSV for the current page.
      For more information about the resource, see Coats, Steven, Carmelo Alessandro Basile, Cameron Morin and Robert Fuchs. (2025). The YouTube Corpus of Singapore English Podcasts. <i>English World-Wide</i>. <a href="https://doi.org/10.1075/eww.25018.coa">https://doi.org/10.1075/eww.25018.coa</a>. A static version of the corpus is available at <a href="https://doi.org/10.7910/DVN/B7JRID">doi.org/10.7910/DVN/B7JRID</a>
    </small>
  </div>

  <div class="row mb-2">
    <div class="col-auto">
      <div class="d-flex align-items-center gap-2">
        <label for="searchInput" class="form-label m-0">Search text:</label>

        <!-- Tiny help popup trigger -->
        <span id="helpBtn" class="help-icon" tabindex="0" role="button"
              data-bs-toggle="popover" data-bs-trigger="focus"
              data-bs-placement="right"
              data-bs-html="true"
              title="Search syntax"
              data-bs-content="
                <div style='max-width: 340px'>
                  <div class='mb-2'><strong>Words</strong>: <code>can</code> matches whole tokens (case-insensitive).</div>
                  <div class='mb-2'><strong>AND</strong>: <code>can think</code> requires both tokens somewhere in the row.</div>
                  <div class='mb-2'><strong>Phrase</strong>: <code>&quot;can can&quot;</code> matches the ordered token sequence.</div>
                  <div class='mb-2'><strong>Wildcards</strong>: <code>can*</code>, <code>*ing</code>, <code>c*n</code> (within a token).</div>
                  <div class='mb-2'><strong>Regex</strong>: <code>re:/pattern/</code> (advanced). Example: <code>re:/c[aeiou]n/</code>.</div>
                  <div class='text-muted'>Matches are checked against <em>Text</em> or <em>POS</em>.</div>
                </div>
              ">?</span>
      </div>

      <input type="text" id="searchInput" class="form-control"
             placeholder='Search text or POS tags (e.g. can* "can can" re:/c[aeiou]n/)'>
      <div class="form-text">Tip: column filters below persist while you sort and run text search.</div>
    </div>

    <div class="col-auto align-self-end d-flex gap-2">
      <button class="btn btn-primary" onclick="doSearch()">Search</button>
      <button class="btn btn-outline-secondary" onclick="clearAllFilters()">Clear all filters</button>
    </div>
  </div>

  <!-- Filter by Channel -->
  <div class="mb-2">
    <strong>Filter by Channel:</strong>
    <div id="channelCheckboxes" class="d-flex flex-wrap gap-3 mt-2"></div>
  </div>

  <!-- Download buttons (current page) -->
  <div class="mb-3 d-flex gap-2">
    <a id="csvBtn" href="#" class="btn btn-outline-success btn-sm d-none">Download CSV (Page)</a>
  </div>

  <div class="mb-2 text-muted" id="hitCount">Loading results...</div>

  <table class="table table-bordered table-striped table-hover table-sm" id="dataTable">
    <thead class="table-dark">
      <!-- SORT HEADER ROW -->
      <tr>
        <th onclick="sortBy('id')">ID<span class="sort-indicator">▴▾</span></th>
        <th onclick="sortBy('channel')">Channel<span class="sort-indicator">▴▾</span></th>
        <th onclick="sortBy('video_id')">Video ID<span class="sort-indicator">▴▾</span></th>
        <th onclick="sortBy('speaker')">Speaker<span class="sort-indicator">▴▾</span></th>
        <th onclick="sortBy('start_time')">Start<span class="sort-indicator">▴▾</span></th>
        <th onclick="sortBy('end_time')">End<span class="sort-indicator">▴▾</span></th>
        <th>Audio</th>
        <th onclick="sortBy('text')">Text<span class="sort-indicator">▴▾</span></th>
        <th onclick="sortBy('pos_tags')">POS<span class="sort-indicator">▴▾</span></th>
      </tr>

      <!-- FILTER ROW -->
      <tr>
        <th class="filter-cell">
          <input class="form-control form-control-sm filter-input" id="f_id" list="dl_id" placeholder="Filter…" autocomplete="off">
          <div class="chips" id="chips_id"></div>
        </th>
        <th class="filter-cell">
          <input class="form-control form-control-sm filter-input" id="f_channel" list="dl_channel" placeholder="Filter…" autocomplete="off">
          <div class="chips" id="chips_channel"></div>
        </th>
        <th class="filter-cell">
          <input class="form-control form-control-sm filter-input" id="f_video_id" list="dl_video_id" placeholder="Filter…" autocomplete="off">
          <div class="chips" id="chips_video_id"></div>
        </th>
        <th class="filter-cell">
          <input class="form-control form-control-sm filter-input" id="f_speaker" list="dl_speaker" placeholder="Filter…" autocomplete="off">
          <div class="chips" id="chips_speaker"></div>
        </th>
        <th class="filter-cell">
          <input class="form-control form-control-sm filter-input" id="f_start_time" list="dl_start_time" placeholder="Filter…" autocomplete="off">
          <div class="chips" id="chips_start_time"></div>
        </th>
        <th class="filter-cell">
          <input class="form-control form-control-sm filter-input" id="f_end_time" list="dl_end_time" placeholder="Filter…" autocomplete="off">
          <div class="chips" id="chips_end_time"></div>
        </th>
        <th class="filter-cell"></th>
        <th class="filter-cell"></th>
        <th class="filter-cell"></th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <!-- DATALISTS (autocomplete sources) -->
  <datalist id="dl_id"></datalist>
  <datalist id="dl_channel"></datalist>
  <datalist id="dl_video_id"></datalist>
  <datalist id="dl_speaker"></datalist>
  <datalist id="dl_start_time"></datalist>
  <datalist id="dl_end_time"></datalist>

  <div class="d-flex justify-content-center my-3" id="paginationControls"></div>

  <script>
    let currentPage = 1;
    let totalRows = 0;
    let pageSize = 100;
    let currentSort = 'id';
    let currentDirection = 'asc';

    // Multi-select column filters: { col: ["A","B"] }
    let columnFilters = {};
    const FILTERABLE_COLS = ["id","channel","video_id","speaker","start_time","end_time"];

    // Highlight patterns received from backend (/data)
    let highlightPatterns = [];

    function debounce(fn, ms=200) {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), ms);
      };
    }

    function getSelectedChannels() {
      const boxes = document.querySelectorAll('#channelCheckboxes input[type=checkbox]:checked');
      return Array.from(boxes).map(cb => cb.value);
    }

    function doSearch() {
      currentPage = 1;
      loadData();
    }

    function sortBy(column) {
      if (currentSort === column) {
        currentDirection = (currentDirection === 'asc') ? 'desc' : 'asc';
      } else {
        currentSort = column;
        currentDirection = 'asc';
      }
      currentPage = 1;
      loadData();
    }

    function goPage(page) {
      if (page < 1) return;
      const totalPages = Math.ceil(totalRows / pageSize);
      if (page > totalPages) return;
      currentPage = page;
      loadData();
    }

    function filtersToParam() {
      return encodeURIComponent(JSON.stringify(columnFilters || {}));
    }

    function clearAllFilters() {
      columnFilters = {};
      FILTERABLE_COLS.forEach(col => {
        const inp = document.getElementById(`f_${col}`);
        if (inp) inp.value = "";
        renderChips(col);
      });
      currentPage = 1;
      loadData();
    }

    function addFilterValue(col, value) {
      const v = String(value || "").trim();
      if (!v) return;

      if (!columnFilters[col]) columnFilters[col] = [];
      if (!columnFilters[col].includes(v)) {
        columnFilters[col].push(v);
      }
      renderChips(col);
    }

    function removeFilterValue(col, value) {
      if (!columnFilters[col]) return;
      columnFilters[col] = columnFilters[col].filter(x => x !== value);
      if (columnFilters[col].length === 0) delete columnFilters[col];
      renderChips(col);
    }

    function renderChips(col) {
      const holder = document.getElementById(`chips_${col}`);
      if (!holder) return;
      holder.innerHTML = "";
      const vals = columnFilters[col] || [];
      vals.forEach(v => {
        const chip = document.createElement("span");
        chip.className = "chip";
        chip.innerHTML = `
          <span class="chip-text" title="${escapeHtml(v)}">${escapeHtml(v)}</span>
          <button class="chip-x" aria-label="Remove" title="Remove">×</button>
        `;
        chip.querySelector(".chip-x").addEventListener("click", (e) => {
          e.preventDefault();
          removeFilterValue(col, v);
          currentPage = 1;
          loadData();
        });
        holder.appendChild(chip);
      });
    }

    function escapeHtml(s) {
      return String(s ?? '')
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }

    function normalizePatternForJS(pat) {
      let s = String(pat || "");
    
      // JS RegExp does NOT support inline flags like (?i)
      // Remove common inline flag groups.
      // - handles (?i) at start
      // - also removes things like (?im) if you ever add them
      s = s.replace(/\(\?[a-z]+\)/gi, "");
    
      return s;
    }
    
    function highlightText(plainText) {
      const s = String(plainText ?? "");
      if (!s) return "";
    
      if (!highlightPatterns || highlightPatterns.length === 0) {
        return escapeHtml(s);
      }
    
      // Escape first to avoid HTML injection
      let html = escapeHtml(s);
    
      const patterns = highlightPatterns.slice(0, 25);
    
      for (const pat of patterns) {
        try {
          const src = normalizePatternForJS(pat);
    
          // Global + case-insensitive (backend already intended (?i))
          const re = new RegExp(src, "gi");
    
          html = html.replace(re, (m) => `<mark class="hl">${m}</mark>`);
        } catch (e) {
          // ignore patterns JS can't compile
        }
      }
      return html;
    }

    const fetchSuggest = debounce((col, prefix) => {
      const textVal = document.getElementById('searchInput').value.trim();
      const selected = getSelectedChannels();
      const channelsParam = encodeURIComponent(selected.join(','));
      const filtersParam = filtersToParam();

      const url = `/suggest?col=${encodeURIComponent(col)}` +
                  `&prefix=${encodeURIComponent(prefix)}` +
                  `&text=${encodeURIComponent(textVal)}` +
                  `&channels=${channelsParam}` +
                  `&filters=${filtersParam}` +
                  `&limit=20`;

      fetch(url)
        .then(r => r.json())
        .then(values => {
          const dl = document.getElementById(`dl_${col}`);
          if (!dl) return;
          dl.innerHTML = "";
          (values || []).forEach(v => {
            const opt = document.createElement("option");
            opt.value = v;
            dl.appendChild(opt);
          });
        })
        .catch(err => console.error("suggest failed", err));
    }, 200);

    function initColumnFilters() {
      FILTERABLE_COLS.forEach(col => {
        const inp = document.getElementById(`f_${col}`);
        if (!inp) return;

        renderChips(col);

        inp.addEventListener("input", (e) => {
          const v = e.target.value || "";
          if (v.length >= 1) fetchSuggest(col, v);
        });

        inp.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            addFilterValue(col, inp.value);
            inp.value = "";
            currentPage = 1;
            loadData();
          } else if (e.key === "Escape") {
            e.preventDefault();
            inp.value = "";
          } else if (e.key === "Backspace" && (inp.value || "").length === 0) {
            const vals = columnFilters[col] || [];
            if (vals.length) {
              removeFilterValue(col, vals[vals.length - 1]);
              currentPage = 1;
              loadData();
            }
          }
        });

        inp.addEventListener("change", (e) => {
          const v = (e.target.value || "").trim();
          if (v) {
            addFilterValue(col, v);
            inp.value = "";
            currentPage = 1;
            loadData();
          }
        });
      });
    }

    function saveState() {
      try {
        const state = {
          columnFilters,
          currentSort,
          currentDirection,
          pageSize
        };
        localStorage.setItem("ycsep_state", JSON.stringify(state));
      } catch (e) {}
    }

    function restoreState() {
      try {
        const raw = localStorage.getItem("ycsep_state");
        if (!raw) return;
        const state = JSON.parse(raw);
        if (state && typeof state === "object") {
          if (state.columnFilters && typeof state.columnFilters === "object") {
            columnFilters = state.columnFilters;
          }
          if (state.currentSort) currentSort = state.currentSort;
          if (state.currentDirection) currentDirection = state.currentDirection;
          if (state.pageSize) pageSize = state.pageSize;
        }
      } catch (e) {}
    }

    function loadData() {
      const inputEl = document.getElementById('searchInput');
      const textVal = inputEl.value.trim();
      const selected = getSelectedChannels();
      const channelsParam = encodeURIComponent(selected.join(','));
      const filtersParam = filtersToParam();

      const url = `/data?page=${currentPage}&size=${pageSize}` +
                  `&text=${encodeURIComponent(textVal)}` +
                  `&sort=${encodeURIComponent(currentSort)}&direction=${encodeURIComponent(currentDirection)}` +
                  `&channels=${channelsParam}` +
                  `&filters=${filtersParam}`;

      fetch(url)
        .then(res => res.json())
        .then(json => {
          totalRows = json.total;
          highlightPatterns = json.highlight || [];
          renderTable(json.data);
          renderPagination();
          renderHitCount();
          updateDownloadLinks(textVal, channelsParam, filtersParam);
          saveState();
        })
        .catch(err => console.error('Error fetching /data:', err));
    }

    function updateDownloadLinks(textVal, channelsParam, filtersParam) {
      const csvBtn = document.getElementById('csvBtn');
      csvBtn.href = `/download/csv?page=${currentPage}&size=${pageSize}` +
                    `&text=${encodeURIComponent(textVal)}` +
                    `&channels=${channelsParam}` +
                    `&filters=${filtersParam}`;
      csvBtn.classList.remove('d-none');
    }

function parseMediaFragment(url) {
  // expects ...#t=start,end
  const s = String(url || "");
  const i = s.indexOf("#t=");
  if (i === -1) return { base: s, start: null, end: null };

  const base = s.slice(0, i);
  const frag = s.slice(i + 3); // after "#t="
  const parts = frag.split(",");
  const start = parts[0] ? parseFloat(parts[0]) : null;
  const end = parts[1] ? parseFloat(parts[1]) : null;
  return {
    base,
    start: Number.isFinite(start) ? start : null,
    end: Number.isFinite(end) ? end : null
  };
}

    function attachSegmentPlayback(audioEl, start, end) {
      if (start == null || end == null) return;
    
      // If user hits play again while already at/after the end, jump back
      audioEl.addEventListener("play", () => {
        if (audioEl.currentTime >= end - 0.05 || audioEl.currentTime < start - 0.05) {
          try { audioEl.currentTime = start; } catch (e) {}
        }
      });
    
      // Hard-stop at segment end (works even if browser ignores #t=end)
      audioEl.addEventListener("timeupdate", () => {
        if (audioEl.currentTime >= end) {
          audioEl.pause();
          try { audioEl.currentTime = start; } catch (e) {}
        }
      });
    
      // Some browsers fire ended on the full file; still reset to start
      audioEl.addEventListener("ended", () => {
        try { audioEl.currentTime = start; } catch (e) {}
      });
    }

    function renderTable(rows) {
  const tbody = document.querySelector('#dataTable tbody');
  tbody.innerHTML = '';

  rows.forEach(r => {
    const audioUrl = r.audio_url || '';
    const { base, start, end } = parseMediaFragment(audioUrl);

    const tr = document.createElement('tr');

    const textHtml = highlightText(r.text);
    const posHtml  = highlightText(r.pos_tags);

    tr.innerHTML = `
      <td>${escapeHtml(r.id)}</td>
      <td>${escapeHtml(r.channel)}</td>
      <td class="mono">${escapeHtml(r.video_id)}</td>
      <td>${escapeHtml(r.speaker)}</td>
      <td>${escapeHtml(r.start_time)}</td>
      <td>${escapeHtml(r.end_time)}</td>
      <td class="audio-cell">
        ${base ? `
          <audio controls preload="none" data-start="${start ?? ''}" data-end="${end ?? ''}">
            <source src="${escapeHtml(base)}" type="audio/wav">
          </audio>
        ` : ''}
      </td>
      <td>${textHtml}</td>
      <td class="mono">${posHtml}</td>
    `;

    tbody.appendChild(tr);

    // Attach segment behavior after element exists
    const audioEl = tr.querySelector("audio");
    if (audioEl && start != null && end != null) {
      attachSegmentPlayback(audioEl, start, end);
    }
  });
}


    function renderPagination() {
      const container = document.getElementById('paginationControls');
      container.innerHTML = '';

      const totalPages = Math.ceil(totalRows / pageSize);
      if (totalPages <= 1) return;

      const nav = document.createElement('nav');
      nav.setAttribute('aria-label', 'Results pages');

      const ul = document.createElement('ul');
      ul.className = 'pagination pagination-sm justify-content-center';

      const makeItem = (label, targetPage, disabled=false, active=false, ariaLabel=null) => {
        const li = document.createElement('li');
        li.className = 'page-item';
        if (disabled) li.classList.add('disabled');
        if (active) li.classList.add('active');

        const a = document.createElement('a');
        a.className = 'page-link';
        a.href = '#';
        if (ariaLabel) a.setAttribute('aria-label', ariaLabel);
        a.textContent = label;

        if (!disabled && !active) {
          a.addEventListener('click', (e) => { e.preventDefault(); goPage(targetPage); });
        }

        li.appendChild(a);
        return li;
      };

      const addEllipsis = () => {
        const li = document.createElement('li');
        li.className = 'page-item disabled';
        const span = document.createElement('span');
        span.className = 'page-link';
        span.textContent = '…';
        li.appendChild(span);
        ul.appendChild(li);
      };

      ul.appendChild(makeItem('«', 1, currentPage === 1, false, 'First'));
      ul.appendChild(makeItem('‹', Math.max(1, currentPage - 1), currentPage === 1, false, 'Previous'));

      const windowSize = 2;
      let start = Math.max(1, currentPage - windowSize);
      let end = Math.min(totalPages, currentPage + windowSize);

      if (start > 1) {
        ul.appendChild(makeItem('1', 1, false, currentPage === 1, 'Page 1'));
        if (start > 2) addEllipsis();
      }

      for (let p = start; p <= end; p++) {
        ul.appendChild(makeItem(String(p), p, false, p === currentPage, `Page ${p}`));
      }

      if (end < totalPages) {
        if (end < totalPages - 1) addEllipsis();
        ul.appendChild(makeItem(String(totalPages), totalPages, false, currentPage === totalPages, `Page ${totalPages}`));
      }

      ul.appendChild(makeItem('›', Math.min(totalPages, currentPage + 1), currentPage === totalPages, false, 'Next'));
      ul.appendChild(makeItem('»', totalPages, currentPage === totalPages, false, 'Last'));

      nav.appendChild(ul);
      container.appendChild(nav);
    }

    function renderHitCount() {
      const counter = document.getElementById('hitCount');
      const parts = [];

      const activeCols = FILTERABLE_COLS.filter(c => (columnFilters[c] || []).length);
      if (activeCols.length) {
        const chipsSummary = activeCols
          .map(c => `${c}=${(columnFilters[c] || []).length}`)
          .join(", ");
        parts.push(`Filters: ${chipsSummary}.`);
      }

      if (highlightPatterns && highlightPatterns.length) {
        parts.push(`Highlighting: ${highlightPatterns.length} pattern(s).`);
      }

      parts.push(`${totalRows} results found.`);
      counter.textContent = parts.join(" ");
    }

    function loadChannels() {
      fetch('/channels')
        .then(res => res.json())
        .then(channels => {
          const container = document.getElementById('channelCheckboxes');
          container.innerHTML = '';
          channels.forEach(c => {
            const label = document.createElement('label');
            label.classList.add('form-check', 'me-3');

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.classList.add('form-check-input', 'me-1');
            checkbox.value = c;

            const saved = localStorage.getItem("ycsep_channels");
            if (saved) {
              try {
                const sel = JSON.parse(saved);
                checkbox.checked = sel.includes(c);
              } catch {
                checkbox.checked = true;
              }
            } else {
              checkbox.checked = true;
            }

            checkbox.addEventListener('change', () => {
              try {
                const selected = getSelectedChannels();
                localStorage.setItem("ycsep_channels", JSON.stringify(selected));
              } catch (e) {}
              doSearch();
            });

            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(c));
            container.appendChild(label);
          });
        })
        .catch(err => console.error('Failed to load channels:', err));
    }

    function initHelpPopover() {
      const el = document.getElementById("helpBtn");
      if (!el) return;
      // eslint-disable-next-line no-undef
      new bootstrap.Popover(el);
    }

    window.addEventListener('DOMContentLoaded', () => {
      restoreState();
      loadChannels();
      initColumnFilters();
      FILTERABLE_COLS.forEach(renderChips);

      initHelpPopover();
      loadData();

      document.getElementById('searchInput').addEventListener('keydown', e => {
        if (e.key === 'Enter') doSearch();
      });

      document.addEventListener("keydown", (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "k") {
          e.preventDefault();
          document.getElementById("searchInput")?.focus();
        }
      });
    });
  </script>
</body>
</html>


